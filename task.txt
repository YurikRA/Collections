Задание 1

Классы:
Part1 - содержит моделирование консольного ввода/вывода и вызов метода WordContainer.main
WordContainer - содержит требуемуую по условию функциональность
Word - поставлен в соответствие сущности 'слово с информацией о его частоте в тексте'.
-------------------------------------------------------

Разработать приложение, которое считывает текст из консольного ввода и выводит слова в порядке убывания частоты их появления в тексте (при совпадении частот порядок - лексикографичекий).
Под словами понимать непрерывную последовательность непробельных символов.

Решить задачу с применением ООП подхода.

Класс Word, содержит строковое поле content и целое поле frequency, контейнер WordContainer агрегирует объекты Word.

При использовании контейнерных классов из ядра грамотно реализовать (если они будут нужны) методы Word#equals / Word#hashCode / Word#compareTo.

При запуске WordContainer.main осуществляет чтение из стандартного потока ввода (консоли). Консольный ввод в общем случае может содержать несколько строк, в каждой строке может быть несколько слов. Признаком завершения консольного ввода служит слово stop.

Продемонстрировать работу приложения (Par1.main).

Пример входной информации
-------------------------------------------------------
asd asdf asd asdf asdf
43 asdsf 43 43
434 stop
-------------------------------------------------------

Пример выходной информации
-------------------------------------------------------
43 : 3
asdf : 3
asd : 2
434 : 1
asdsf : 1
-------------------------------------------------------
_______________________


Задание 2

-------------------------------------------------------

Написать программу, которая моделирует следующий процесс.

В кругу стоят n человек, пронумерованных от 0 до n-1.
При ведении счета по кругу вычеркивается каждый k-й человек (0<k<n), пока не останется один.

Решить задачу двумя способами:

1) при помощи удаления элемента по индексу самим контейнером [List#remove(int)]
-------------------------------------------------------
// метод возвращает время работы
public static long removeByIndex(List<?> list, int k) {}
-------------------------------------------------------

2) при помощи удаления элемента с помощью итератора [Iterator#remove()]
-------------------------------------------------------
// метод возвращает время работы
public static long removeByIterator(List<?> list, int k) {}
-------------------------------------------------------

Сравнить время работы каждого способа на одинаковых входных данных (задавать в Part2.main) с использованием объектов ArrayList и LinkedList.
В качестве входных данных использовать n=10000, k=4, списки заполнить случайными числами.

Продемонстрировать работу приложения (Par2.main)

Пример выходной информации (придерживаться данного формата).
-------------------------------------------------------
ArrayList#Index: 13 ms
LinkedList#Index: 93 ms
ArrayList#Iterator: 20 ms
LinkedList#Iterator: 15 ms
-------------------------------------------------------
_______________________

Задание 3

-------------------------------------------------------

Реализовать класс Parking, моделирующий работу n-местной автостоянки.

Машина подъезжает к определенному месту и едет вправо, пока не встретится свободное место.
Класс должен поддерживать методы, обслуживающие приезд и отъезд машины.
Определить метод, который выводит в консоль текущее состояние стоянки.

Продемонстрировать работу приложения (Part3.main).

_______________________

Задание 4

-------------------------------------------------------

Реализовать класс Graph, представляющий собой неориентированный граф.
В конструкторе класса передаётся количество вершин в графе.
Методы должны поддерживать быстрое добавление и удаление рёбер.

Продемонстрировать работу приложения (Part4.main).

_______________________

Задание 5

-------------------------------------------------------

Создать generic класс Tree, который реализует структуру данных "двоичное дерево поиска". Контейнерные классы не использовать.
Результат вывода Part5.main (отступ 2 пробела):
-------------------------------------------------------
true
false
~~~~~~~
    0
  1
    2
3
    4
  5
    6
~~~~~~~

При удалении элемента придерживаться следующего алгоритма.
1. Если у узла нет дочерних узлов, то у его родителя нужно просто заменить указатель на null.
2. Если у узла есть только один дочерний узел, то нужно создать новую связь между родителем удаляемого узла и его дочерним узлом.
3. Если у узла два дочерних узла, то нужно
3.1. найти следующий за ним элемент (у этого элемента не будет правого потомка)
3.2. его левого потомка подвесить на место найденного элемента
3.3. удаляемый узел заменить найденным узлом.
_______________________

Задание 6

Входную информацию загружать из файла part6.txt (должен находится в корне проекта)
-------------------------------------------------------

Реализовать консольное приложение (Part6) которое анализирует текст.

Формат входных параметров командной строки для приложения (программа должна понимать как короткие, так и длинные опции):
-------------------------------------------------------
-i (или --input) путь к входному файлу;
-t (или --task) наименование подзадачи.
-------------------------------------------------------

Всего параметров командной строки 4, т.е. две пары <имя_опции значение_опции>.
Порядок следования опций с их значениями прооизвольный.

Примеры параметров командной строки для запуска приложения:
-------------------------------------------------------
-i input.txt -t frequency
--input input.txt --task length
-------------------------------------------------------

Подзадач всего три: frequency, length, duplicates.

Подзадача Part 1 (frequency)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.Part61
-------------------------------------------------------

Во входном файле найти три слова, которые встречаются наиболее часто (при совпадении частот – те, которые встречаются раньше), и распечатать их отсортированными по алфавиту в обратном порядке в формате: слово ==> частота

Пример вывода
-------------------------------------------------------
panda ==> 15
ezhik ==> 20
apple ==> 19
-------------------------------------------------------

Подзадача Part 2 (length)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.part6.Part62
-------------------------------------------------------

Во входном файле найти три самых длинных слова и распечатать их в формате: слово ==> количество букв в слове. Список должен быть отсортирован по убыванию количества букв в слове.

Если у двух слов количество букв совпадает, то слово, которое было в исходном файле раньше, должно в результирующем списке находиться также раньше.

Пример вывода
-------------------------------------------------------
anesthetist ==> 11
kitchen ==> 7
bird ==> 4
-------------------------------------------------------

Подзадача Part 3 (duplicates)
-------------------------------------------------------
Название класса: ua.nure.your_last_name.practice6.part6.Part62
-------------------------------------------------------

Во входном файле найти первые три слова, которые имеют дубликаты, и напечатать их инверсию в верхнем регистре.

Пример вывода
-------------------------------------------------------
ADNAP
TAC
ENIGREBUA
-------------------------------------------------------

_______________________

Задание 7

-------------------------------------------------------

Написать класс Range, который бы представлял собой промежуток чисел [n, m], где n < m.
Класс должен реализовывать интерфейс Iterable.
Итератор реализовать таким образом, чтобы он проходил он начала до конца промежутка.
В конструктор передавать дополнительный параметр reverse.

Класс Range должен иметь два конструктора:
-------------------------------------------------------
public Range(int n, int m) { ... }
public Range(int n, int m, boolean reverse) { ... }
-------------------------------------------------------
